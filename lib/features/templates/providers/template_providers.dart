import 'dart:io';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:path/path.dart' as path;
import 'package:path_provider/path_provider.dart';
import 'package:riverpod_annotation/riverpod_annotation.dart';
import 'package:image_ocr/features/templates/models/folder.dart';
import 'package:image_ocr/features/templates/models/template.dart';
import 'package:image_ocr/features/templates/services/template_service.dart';
import 'package:uuid/uuid.dart';

part 'template_providers.g.dart';

// --- Core Providers generated by Riverpod Generator ---

@Riverpod(keepAlive: true)
Future<TemplateService> templateService(TemplateServiceRef ref) async {
  return await TemplateService.create();
}

@riverpod
class FolderNavigationStack extends _$FolderNavigationStack {
  @override
  List<String?> build() => [null]; // Start at the root

  void push(String folderId) {
    state = [...state, folderId];
  }

  void pop() {
    if (state.length > 1) {
      state = state.sublist(0, state.length - 1);
    }
  }

  void popTo(int index) {
    if (index >= 0 && index < state.length) {
      state = state.sublist(0, index + 1);
    }
  }
}

@riverpod
String? currentFolderId(CurrentFolderIdRef ref) {
  return ref.watch(folderNavigationStackProvider).last;
}

@riverpod
Future<List<dynamic>> folderContents(
    FolderContentsRef ref, String? folderId) async {
  final service = await ref.watch(templateServiceProvider.future);

  List<String> childrenIds;
  if (folderId == null) {
    childrenIds = service.getRootOrder();
  } else {
    try {
      final folder = service.getFolders().firstWhere((f) => f.id == folderId);
      childrenIds = folder.childrenIds;
    } catch (e) {
      childrenIds = []; // Folder not found, return empty contents.
    }
  }

  final allTemplates = service.getTemplates();
  final allFolders = service.getFolders();

  final contentsMap = <String, dynamic>{};
  for (var item in [...allTemplates, ...allFolders]) {
    // HiveObject doesn't have a common interface for id, so we cast to dynamic
    contentsMap[(item as dynamic).id] = item;
  }

  final sortedContents = childrenIds
      .map((id) => contentsMap[id])
      .where((item) => item != null)
      .toList();

  return sortedContents;
}

@riverpod
Future<List<Folder?>> folderPath(FolderPathRef ref) async {
  final service = await ref.watch(templateServiceProvider.future);
  final stack = ref.watch(folderNavigationStackProvider);
  final allFolders = service.getFolders();

  return stack.map((id) {
    if (id == null) return null; // Represents the "Root"
    try {
      return allFolders.firstWhere((f) => f.id == id);
    } catch (e) {
      // This can happen if a folder in the stack was deleted.
      return Folder(id: id, name: '未知'); // Return a placeholder
    }
  }).toList();
}

@riverpod
class TemplateCreation extends _$TemplateCreation {
  @override
  Template build() {
    // Always return a valid, non-null initial Template object.
    // This solves all the null-safety issues with `copyWith`.
    return Template(
      id: const Uuid().v4(),
      name: '',
      sourceImagePath: '',
      fieldIds: [],
    );
  }

  void createNew({String? folderId}) {
    state = Template(
      id: const Uuid().v4(),
      name: '新模板',
      sourceImagePath: '', // This will be set in the creation screen
      fieldIds: [],
      folderId: folderId,
    );
  }

  Future<void> loadForEditing(Template template) async {
    // --- [DATA CORRUPTION FIX] ---
    // When loading a template for editing, its image path might be a temporary one
    // from a previous session. We must verify it and copy the image to a safe
    // location if it's not already there.
    final appDir = await getApplicationDocumentsDirectory();
    final imageFile = File(template.sourceImagePath);

    if (!imageFile.existsSync()) {
      // If the file doesn't even exist, we can't recover.
      // Set the path to empty to force the user to re-pick an image.
      state = template.copyWith(sourceImagePath: '');
      return;
    }

    if (!path.isWithin(appDir.path, template.sourceImagePath)) {
      // The file exists but is outside our safe directory (it's a temp file).
      // Copy it to a permanent location.
      final fileExtension = path.extension(template.sourceImagePath);
      final newFileName = '${const Uuid().v4()}$fileExtension';
      final permanentPath = path.join(appDir.path, newFileName);
      
      await imageFile.copy(permanentPath);
      
      // Update the state with the new, safe path.
      state = template.copyWith(sourceImagePath: permanentPath);
    } else {
      // The path is already safe, just load it.
      state = template;
    }
  }

  void updateName(String name) {
    state = state.copyWith(name: name);
  }

  void setSourceImage(String path) {
    state = state.copyWith(sourceImagePath: path);
  }

  void addField(String fieldId) {
    if (!state.fieldIds.contains(fieldId)) {
      state = state.copyWith(fieldIds: [...state.fieldIds, fieldId]);
    }
  }

  void removeField(String fieldId) {
    final newFields = state.fieldIds.where((id) => id != fieldId).toList();
    state = state.copyWith(fieldIds: newFields);
  }

  void reorderFields(int oldIndex, int newIndex) {
    final fields = List<String>.from(state.fieldIds);
    if (oldIndex < newIndex) {
      newIndex -= 1;
    }
    final item = fields.removeAt(oldIndex);
    fields.insert(newIndex, item);
    state = state.copyWith(fieldIds: fields);
  }

  Future<void> save() async {
    // --- [DATA CORRUPTION FIX] ---
    // Double-check the image path before saving to ensure it's permanent.
    // This acts as a safeguard against any logic errors.
    final appDir = await getApplicationDocumentsDirectory();
    Template templateToSave = state;

    if (state.sourceImagePath.isNotEmpty && !path.isWithin(appDir.path, state.sourceImagePath)) {
        final imageFile = File(state.sourceImagePath);
        if (await imageFile.exists()) {
            final fileExtension = path.extension(state.sourceImagePath);
            final newFileName = '${const Uuid().v4()}$fileExtension';
            final permanentPath = path.join(appDir.path, newFileName);
            await imageFile.copy(permanentPath);
            templateToSave = state.copyWith(sourceImagePath: permanentPath);
        } else {
            // If the source file doesn't exist, we can't save a broken template.
            // Throw an exception to notify the user.
            throw Exception('源图片文件不存在，无法保存模板。请重新选择图片。');
        }
    }
    
    final service = await ref.read(templateServiceProvider.future);
    await service.saveTemplate(templateToSave);
    state = templateToSave; // Ensure the in-memory state has the correct path too
    ref.invalidate(folderContentsProvider(state.folderId));
  }
}

@riverpod
Future<Template> templateById(TemplateByIdRef ref, String templateId) async {
  final service = await ref.watch(templateServiceProvider.future);
  try {
    return service.getTemplates().firstWhere((t) => t.id == templateId);
  } catch (e) {
    throw Exception('Template with ID $templateId not found.');
  }
}

class TemplatesAndFoldersActions {
  final Ref _ref;
  TemplatesAndFoldersActions(this._ref);

  Future<void> _runTask(Future<void> Function(TemplateService service) task) async {
    final service = await _ref.read(templateServiceProvider.future);
    await task(service);
  }

  Future<void> createFolder(String name, {String? parentId}) async {
    await _runTask((service) async {
      await service.createFolder(name, parentId: parentId);
      _ref.invalidate(folderContentsProvider(parentId));
    });
  }

  Future<void> deleteFolder(String folderId) async {
    await _runTask((service) async {
      final folder = service.getFolders().firstWhere((f) => f.id == folderId);
      final parentId = folder.parentId;
      await service.deleteFolder(folderId);
      _ref.invalidate(folderContentsProvider(parentId));
    });
  }

  Future<void> updateFolder(String folderId, String newName) async {
    await _runTask((service) async {
      final folder = service.getFolders().firstWhere((f) => f.id == folderId);
      await service.updateFolder(folderId, newName);
      _ref.invalidate(folderContentsProvider(folder.parentId));
    });
  }

  Future<void> deleteTemplate(String templateId) async {
    await _runTask((service) async {
      final template = service.getTemplates().firstWhere((t) => t.id == templateId);
      final folderId = template.folderId;
      await service.deleteTemplate(templateId);
      _ref.invalidate(folderContentsProvider(folderId));
    });
  }

  Future<void> reorderChildren(String? folderId, int oldIndex, int newIndex) async {
    await _runTask((service) async {
      await service.reorderChildren(folderId, oldIndex, newIndex);
      _ref.invalidate(folderContentsProvider(folderId));
    });
  }

  Future<void> moveItemToFolder({
    required String itemId,
    required bool isFolder,
    required String? sourceFolderId,
    required String? targetFolderId,
  }) async {
    if (itemId == targetFolderId) return;

    await _runTask((service) async {
      if (isFolder) {
        await service.moveFolderToFolder(itemId, targetFolderId);
      } else {
        await service.moveTemplateToFolder(itemId, targetFolderId);
      }
      _ref.invalidate(folderContentsProvider(sourceFolderId));
      _ref.invalidate(folderContentsProvider(targetFolderId));
    });
  }
}

@riverpod
TemplatesAndFoldersActions templatesAndFoldersActions(TemplatesAndFoldersActionsRef ref) {
  return TemplatesAndFoldersActions(ref);
}
import 'dart:io';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:path/path.dart' as path;
import 'package:path_provider/path_provider.dart';
import 'package:riverpod_annotation/riverpod_annotation.dart';
import 'package:shared_preferences/shared_preferences.dart';
import 'package:image_ocr/features/templates/models/folder.dart';
import 'package:image_ocr/features/templates/models/template.dart';
import 'package:image_ocr/features/templates/services/template_service.dart' as template_service_lib;
import 'package:uuid/uuid.dart';

part 'template_providers.g.dart';

// --- Core Providers generated by Riverpod Generator ---

@riverpod
class TemplateService extends _$TemplateService {
  @override
  Future<template_service_lib.TemplateService> build() async {
    return await template_service_lib.TemplateService.create();
  }
}

const String _navigationStackKey = 'folderNavigationStack';

@Riverpod(keepAlive: true)
class FolderNavigationStack extends _$FolderNavigationStack {
  
  Future<SharedPreferences> _getPrefs() async => await SharedPreferences.getInstance();

  @override
  Future<List<String?>> build() async {
    final prefs = await _getPrefs();
    final storedStack = prefs.getStringList(_navigationStackKey);
    if (storedStack != null && storedStack.isNotEmpty) {
      // SharedPreferences doesn't support nulls in lists, so we use a placeholder
      return storedStack.map((id) => id == 'null' ? null : id).toList();
    }
    return [null]; // Default to root
  }

  Future<void> _saveStack(List<String?> stack) async {
    final prefs = await _getPrefs();
    // SharedPreferences doesn't support nulls in lists, so we use a placeholder
    final storableStack = stack.map((id) => id ?? 'null').toList();
    await prefs.setStringList(_navigationStackKey, storableStack);
  }

  Future<void> push(String folderId) async {
    final currentStack = state.valueOrNull ?? [null];
    final newStack = [...currentStack, folderId];
    state = AsyncData(newStack);
    await _saveStack(newStack);
  }

  Future<void> pop() async {
    final currentStack = state.valueOrNull ?? [null];
    if (currentStack.length > 1) {
      final newStack = currentStack.sublist(0, currentStack.length - 1);
      state = AsyncData(newStack);
      await _saveStack(newStack);
    }
  }

  Future<void> popTo(int index) async {
    final currentStack = state.valueOrNull ?? [null];
    if (index >= 0 && index < currentStack.length) {
      final newStack = currentStack.sublist(0, index + 1);
      state = AsyncData(newStack);
      await _saveStack(newStack);
    }
  }
}

@riverpod
class CurrentFolderId extends _$CurrentFolderId {
  @override
  String? build() {
    // Now depends on the async navigation stack
    return ref.watch(folderNavigationStackProvider).when(
      data: (stack) => stack.last,
      loading: () => null, // Or a specific loading state if needed
      error: (_, __) => null, // Handle error case
    );
  }
}

@riverpod
class FolderContents extends _$FolderContents {
  @override
  Future<List<dynamic>> build(String? folderId) async {
    final service = await ref.watch(templateServiceProvider.future);

    List<String> childrenIds;
    if (folderId == null) {
      childrenIds = service.getRootOrder();
    } else {
      try {
        final folder = service.getFolders().firstWhere((f) => f.id == folderId);
        childrenIds = folder.childrenIds;
      } catch (e) {
        childrenIds = []; // Folder not found, return empty contents.
      }
    }

    final allTemplates = service.getTemplates();
    final allFolders = service.getFolders();

    final contentsMap = <String, dynamic>{};
    for (var item in [...allTemplates, ...allFolders]) {
      // HiveObject doesn't have a common interface for id, so we cast to dynamic
      contentsMap[(item as dynamic).id] = item;
    }

    final sortedContents =
        childrenIds.map((id) => contentsMap[id]).where((item) => item != null).toList();

    return sortedContents;
  }
}

@riverpod
class FolderPath extends _$FolderPath {
  @override
  Future<List<Folder?>> build() async {
    final service = await ref.watch(templateServiceProvider.future);
    // Now depends on the async navigation stack
    final stackAsync = ref.watch(folderNavigationStackProvider);

    return await stackAsync.when(
      data: (stack) {
        final allFolders = service.getFolders();
        return stack.map((id) {
          if (id == null) return null; // Represents the "Root"
          try {
            return allFolders.firstWhere((f) => f.id == id);
          } catch (e) {
            // This can happen if a folder in the stack was deleted.
            return Folder(id: id, name: '未知'); // Return a placeholder
          }
        }).toList();
      },
      // Return empty list while loading or on error
      loading: () async => [],
      error: (_, __) async => [],
    );
  }
}

@riverpod
class TemplateCreation extends _$TemplateCreation {
  @override
  Template build() {
    // Always return a valid, non-null initial Template object.
    // This solves all the null-safety issues with `copyWith`.
    return Template(
      id: const Uuid().v4(),
      name: '',
      sourceImagePath: '',
      fieldIds: [],
    );
  }

  void createNew({String? folderId}) {
    state = Template(
      id: const Uuid().v4(),
      name: '新模板',
      sourceImagePath: '', // This will be set in the creation screen
      fieldIds: [],
      folderId: folderId,
    );
  }

  Future<void> loadForEditing(Template template) async {
    // --- [DATA CORRUPTION FIX] ---
    // When loading a template for editing, its image path might be a temporary one
    // from a previous session. We must verify it and copy the image to a safe
    // location if it's not already there.
    final appDir = await getApplicationDocumentsDirectory();
    final imageFile = File(template.sourceImagePath);

    if (!imageFile.existsSync()) {
      // If the file doesn't even exist, we can't recover.
      // Set the path to empty to force the user to re-pick an image.
      state = template.copyWith(sourceImagePath: '');
      return;
    }

    if (!path.isWithin(appDir.path, template.sourceImagePath)) {
      // The file exists but is outside our safe directory (it's a temp file).
      // Copy it to a permanent location.
      final fileExtension = path.extension(template.sourceImagePath);
      final newFileName = '${const Uuid().v4()}$fileExtension';
      final permanentPath = path.join(appDir.path, newFileName);
      
      await imageFile.copy(permanentPath);
      
      // Update the state with the new, safe path.
      state = template.copyWith(sourceImagePath: permanentPath);
    } else {
      // The path is already safe, just load it.
      state = template;
    }
  }

  void updateName(String name) {
    state = state.copyWith(name: name);
  }

  void setSourceImage(String path) {
    state = state.copyWith(sourceImagePath: path);
  }

  void addField(String fieldId) {
    if (!state.fieldIds.contains(fieldId)) {
      state = state.copyWith(fieldIds: [...state.fieldIds, fieldId]);
    }
  }

  void removeField(String fieldId) {
    final newFields = state.fieldIds.where((id) => id != fieldId).toList();
    state = state.copyWith(fieldIds: newFields);
  }

  void reorderFields(int oldIndex, int newIndex) {
    final fields = List<String>.from(state.fieldIds);
    if (oldIndex < newIndex) {
      newIndex -= 1;
    }
    final item = fields.removeAt(oldIndex);
    fields.insert(newIndex, item);
    state = state.copyWith(fieldIds: fields);
  }

  Future<void> save() async {
    // --- [DATA CORRUPTION FIX] ---
    // Double-check the image path before saving to ensure it's permanent.
    // This acts as a safeguard against any logic errors.
    final appDir = await getApplicationDocumentsDirectory();
    Template templateToSave = state;

    if (state.sourceImagePath.isNotEmpty && !path.isWithin(appDir.path, state.sourceImagePath)) {
        final imageFile = File(state.sourceImagePath);
        if (await imageFile.exists()) {
            final fileExtension = path.extension(state.sourceImagePath);
            final newFileName = '${const Uuid().v4()}$fileExtension';
            final permanentPath = path.join(appDir.path, newFileName);
            await imageFile.copy(permanentPath);
            templateToSave = state.copyWith(sourceImagePath: permanentPath);
        } else {
            // If the source file doesn't exist, we can't save a broken template.
            // Throw an exception to notify the user.
            throw Exception('源图片文件不存在，无法保存模板。请重新选择图片。');
        }
    }
    
    final service = await ref.read(templateServiceProvider.future);
    await service.saveTemplate(templateToSave);
    state = templateToSave; // Ensure the in-memory state has the correct path too
    ref.invalidate(folderContentsProvider(state.folderId));
  }
}

@riverpod
class TemplateById extends _$TemplateById {
  @override
  Future<Template> build(String id) async {
    final service = await ref.watch(templateServiceProvider.future);
    try {
      return service.getTemplates().firstWhere((t) => t.id == id);
    } catch (e) {
      throw Exception('Template with ID $id not found.');
    }
  }
}

@riverpod
class AllTemplates extends _$AllTemplates {
  @override
  Future<List<Template>> build() async {
    final service = await ref.watch(templateServiceProvider.future);
    return service.getTemplates();
  }
}

// Renamed to avoid conflict with the provider class name
class TemplatesAndFoldersActionsLogic {
  final Ref _ref;
  TemplatesAndFoldersActionsLogic(this._ref);

  Future<void> _runTask(Future<void> Function(template_service_lib.TemplateService service) task) async {
    final service = await _ref.read(templateServiceProvider.future);
    await task(service);
  }

  Future<void> createFolder(String name, {String? parentId}) async {
    await _runTask((service) async {
      await service.createFolder(name, parentId: parentId);
      _ref.invalidate(folderContentsProvider(parentId));
    });
  }

  Future<void> deleteFolder(String folderId) async {
    await _runTask((service) async {
      final folder = service.getFolders().firstWhere((f) => f.id == folderId);
      final parentId = folder.parentId;
      await service.deleteFolder(folderId);
      _ref.invalidate(folderContentsProvider(parentId));
    });
  }

  Future<void> updateFolder(String folderId, String newName) async {
    await _runTask((service) async {
      final folder = service.getFolders().firstWhere((f) => f.id == folderId);
      await service.updateFolder(folderId, newName);
      _ref.invalidate(folderContentsProvider(folder.parentId));
    });
  }

  Future<void> deleteTemplate(String templateId) async {
    await _runTask((service) async {
      final template = service.getTemplates().firstWhere((t) => t.id == templateId);
      final folderId = template.folderId;
      await service.deleteTemplate(templateId);
      _ref.invalidate(folderContentsProvider(folderId));
    });
  }

  Future<void> reorderChildren(String? folderId, int oldIndex, int newIndex) async {
    await _runTask((service) async {
      await service.reorderChildren(folderId, oldIndex, newIndex);
      _ref.invalidate(folderContentsProvider(folderId));
    });
  }

  Future<void> moveItemToFolder({
    required String itemId,
    required bool isFolder,
    required String? sourceFolderId,
    required String? targetFolderId,
  }) async {
    if (itemId == targetFolderId) return;

    await _runTask((service) async {
      if (isFolder) {
        await service.moveFolderToFolder(itemId, targetFolderId);
      } else {
        await service.moveTemplateToFolder(itemId, targetFolderId);
      }
      _ref.invalidate(folderContentsProvider(sourceFolderId));
      _ref.invalidate(folderContentsProvider(targetFolderId));
    });
  }
}

@riverpod
class TemplatesAndFoldersActions extends _$TemplatesAndFoldersActions {
  @override
  TemplatesAndFoldersActionsLogic build() {
    return TemplatesAndFoldersActionsLogic(ref);
  }
}

// --- UI-specific Providers ---

/// Holds the set of templates selected for a processing job (either from overlay or main screen).
final selectedTemplatesForProcessingProvider = StateProvider<Set<Template>>((ref) => {});